diff --git a/src/boe_mcp/server.py b/src/boe_mcp/server.py
index 95168ef..1d3303b 100644
--- a/src/boe_mcp/server.py
+++ b/src/boe_mcp/server.py
@@ -763,6 +763,241 @@ def _extraer_numero_articulo(titulo: str) -> str:
     return ""
 
 
+@mcp.tool()
+async def get_article_modifications(
+    identifier: str,
+    articulo: str
+) -> dict:
+    """
+    Verifica si un artículo específico ha sido modificado y por qué normas.
+
+    Esta herramienta permite monitorizar cambios en artículos concretos de leyes.
+    Devuelve información compacta (~300-600 bytes) sobre el historial de
+    modificaciones, ideal para:
+    - Verificar si un artículo que afecta a un procedimiento sigue vigente
+    - Monitorización automatizada (cron) de cambios en artículos específicos
+    - Auditorías de cumplimiento normativo
+
+    NOTA: Esta herramienta NO devuelve el texto del artículo. Para obtenerlo,
+    usar get_article_info con incluir_texto=True.
+
+    Args:
+        identifier: ID BOE de la ley (ej. "BOE-A-2015-10565" para Ley 39/2015)
+        articulo: Número del artículo a consultar. Formatos válidos:
+            - Número simple: "1", "28", "77"
+            - Con sufijo latino: "224 bis", "37 quater"
+            - Artículo único: "único"
+
+    Returns:
+        Diccionario con:
+        - modificado: True si el artículo fue modificado después de la publicación
+        - articulo: Número consultado
+        - ley_id: Identificador de la ley
+        - titulo_articulo: Título del artículo (ej. "Documentos aportados...")
+        - fecha_version_original: Fecha de publicación de la ley (AAAAMMDD)
+        - fecha_version_actual: Fecha de la última versión del artículo
+        - total_versiones: Número de versiones del artículo (1 = sin modificar)
+        - modificaciones: Lista de modificaciones con:
+            - version: Número de versión (2, 3, ...)
+            - norma_modificadora: ID BOE de la norma que modifica
+            - fecha_publicacion: Fecha de publicación de la modificación
+            - fecha_vigencia: Fecha de entrada en vigor
+            - descripcion: Descripción del cambio (si disponible)
+
+        En caso de error:
+        - error: True
+        - codigo: "VALIDATION_ERROR" | "LEY_NO_ENCONTRADA" | "ARTICULO_NO_ENCONTRADO"
+        - mensaje: Descripción del error
+
+    Examples:
+        >>> get_article_modifications("BOE-A-2015-10565", "28")
+        {
+            "modificado": True,
+            "articulo": "28",
+            "fecha_version_actual": "20181206",
+            "total_versiones": 2,
+            "modificaciones": [{"norma_modificadora": "BOE-A-2018-16673", ...}]
+        }
+
+        >>> get_article_modifications("BOE-A-2015-10565", "21")
+        {
+            "modificado": False,
+            "articulo": "21",
+            "fecha_version_actual": "20151002",
+            "total_versiones": 1,
+            "modificaciones": []
+        }
+    """
+    # 1. VALIDACIÓN
+    try:
+        identifier = validate_boe_identifier(identifier)
+        articulo = validate_articulo(articulo)
+    except ValidationError as e:
+        return {
+            "error": True,
+            "codigo": "VALIDATION_ERROR",
+            "mensaje": str(e),
+            "detalles": None
+        }
+
+    # 2. OBTENER ÍNDICE PARA ENCONTRAR EL ARTÍCULO Y FECHA ORIGINAL
+    base = f"/datosabiertos/api/legislacion-consolidada/id/{identifier}"
+    indice_endpoint = f"{base}/texto/indice"
+
+    indice_xml = await make_boe_raw_request(indice_endpoint, accept="application/xml")
+
+    if indice_xml is None:
+        return {
+            "error": True,
+            "codigo": "LEY_NO_ENCONTRADA",
+            "mensaje": f"No se pudo recuperar la ley {identifier}",
+            "detalles": {"identifier": identifier}
+        }
+
+    # 3. PARSEAR ÍNDICE PARA ENCONTRAR BLOCK_ID Y FECHA ORIGINAL
+    try:
+        root = ET.fromstring(indice_xml)
+        bloques = root.findall(".//bloque")
+    except ET.ParseError as e:
+        return {
+            "error": True,
+            "codigo": "ERROR_PARSING",
+            "mensaje": "Error procesando respuesta de la API",
+            "detalles": {"error_xml": str(e)}
+        }
+
+    if not bloques:
+        return {
+            "error": True,
+            "codigo": "ERROR_PARSING",
+            "mensaje": "La ley no contiene bloques de texto",
+            "detalles": None
+        }
+
+    # Obtener fecha original de la ley (la más antigua)
+    fechas = []
+    for bloque in bloques:
+        fecha_elem = bloque.find("fecha_actualizacion")
+        if fecha_elem is not None and fecha_elem.text:
+            fechas.append(fecha_elem.text)
+
+    fecha_ley_original = min(fechas) if fechas else ""
+
+    # Buscar el artículo en el índice
+    if articulo.lower() == "único":
+        patron_titulo = "artículo único"
+    else:
+        patron_titulo = f"artículo {articulo}"
+
+    block_id = None
+    titulo_articulo = ""
+
+    for bloque in bloques:
+        titulo_elem = bloque.find("titulo")
+        if titulo_elem is None or titulo_elem.text is None:
+            continue
+
+        titulo = titulo_elem.text.lower().replace('\xa0', ' ')
+
+        if titulo.startswith(patron_titulo):
+            siguiente_char_idx = len(patron_titulo)
+            if siguiente_char_idx < len(titulo):
+                siguiente_char = titulo[siguiente_char_idx]
+                if siguiente_char not in ". ":
+                    continue
+
+            id_elem = bloque.find("id")
+            block_id = id_elem.text if id_elem is not None else None
+            # Título original normalizado (sin non-breaking spaces)
+            titulo_articulo = titulo_elem.text.replace('\xa0', ' ')
+            break
+
+    if block_id is None:
+        return {
+            "error": True,
+            "codigo": "ARTICULO_NO_ENCONTRADO",
+            "mensaje": f"No se encontró el artículo {articulo} en {identifier}",
+            "detalles": {"identifier": identifier, "articulo": articulo}
+        }
+
+    # 4. OBTENER BLOQUE CON VERSIONES
+    bloque_endpoint = f"{base}/texto/bloque/{block_id}"
+    bloque_xml = await make_boe_raw_request(bloque_endpoint, accept="application/xml")
+
+    if bloque_xml is None:
+        return {
+            "error": True,
+            "codigo": "ERROR_API",
+            "mensaje": f"No se pudo recuperar el bloque {block_id}",
+            "detalles": {"block_id": block_id}
+        }
+
+    # 5. PARSEAR VERSIONES DEL BLOQUE
+    try:
+        bloque_root = ET.fromstring(bloque_xml)
+        versiones = bloque_root.findall(".//version")
+    except ET.ParseError as e:
+        return {
+            "error": True,
+            "codigo": "ERROR_PARSING",
+            "mensaje": "Error procesando bloque de la API",
+            "detalles": {"error_xml": str(e)}
+        }
+
+    # 6. EXTRAER INFORMACIÓN DE VERSIONES
+    total_versiones = len(versiones) if versiones else 1
+    modificaciones = []
+
+    if versiones and len(versiones) > 0:
+        version_original = versiones[0]
+        version_actual = versiones[-1]
+
+        fecha_version_original = version_original.get("fecha_publicacion", fecha_ley_original)
+        fecha_version_actual = version_actual.get("fecha_publicacion", fecha_ley_original)
+
+        # Extraer modificaciones (todas excepto la primera versión)
+        for i, version in enumerate(versiones[1:], start=2):
+            # Buscar nota explicativa
+            nota_elem = version.find(".//p[@class='nota_pie']")
+            descripcion = nota_elem.text if nota_elem is not None else None
+
+            # Si no hay nota_pie directa, buscar en blockquote
+            if descripcion is None:
+                blockquote = version.find(".//blockquote")
+                if blockquote is not None:
+                    nota_elem = blockquote.find(".//p[@class='nota_pie']")
+                    if nota_elem is not None:
+                        # Extraer texto incluyendo posibles hijos
+                        descripcion = "".join(nota_elem.itertext()).strip()
+
+            modificaciones.append({
+                "version": i,
+                "norma_modificadora": version.get("id_norma", ""),
+                "fecha_publicacion": version.get("fecha_publicacion", ""),
+                "fecha_vigencia": version.get("fecha_vigencia", ""),
+                "descripcion": descripcion
+            })
+    else:
+        # Sin versiones encontradas, usar fecha del índice
+        fecha_version_original = fecha_ley_original
+        fecha_version_actual = fecha_ley_original
+
+    # 7. DETERMINAR SI FUE MODIFICADO
+    modificado = total_versiones > 1
+
+    # 8. RETORNAR RESULTADO COMPACTO
+    return {
+        "modificado": modificado,
+        "articulo": articulo,
+        "ley_id": identifier,
+        "titulo_articulo": titulo_articulo,
+        "fecha_version_original": fecha_version_original,
+        "fecha_version_actual": fecha_version_actual,
+        "total_versiones": total_versiones,
+        "modificaciones": modificaciones
+    }
+
+
 @mcp.tool()
 async def search_in_law(
     identifier: str,
@@ -1220,7 +1455,7 @@ def _es_estructura(id_bloque: str) -> bool:
 async def get_law_index(
     identifier: str,
     tipo_bloque: Literal["todos", "estructura", "articulos", "disposiciones"] = "todos",
-    limit: int = 100,
+    limit: int = 20,
     offset: int = 0
 ) -> dict:
     """
@@ -1236,7 +1471,7 @@ async def get_law_index(
             - "estructura": Solo libros, títulos, capítulos y secciones
             - "articulos": Solo artículos
             - "disposiciones": Solo disposiciones (adicionales, transitorias, etc.)
-        limit: Máximo de bloques a devolver (1-500, default: 100)
+        limit: Máximo de bloques a devolver (1-500, default: 20)
         offset: Índice inicial para paginación (default: 0)
 
     Returns:
@@ -1482,14 +1717,13 @@ def _extraer_items_seccion(seccion: dict) -> list[dict]:
 
     for dept in depts:
         dept_nombre = dept.get("nombre", "")
-        dept_codigo = dept.get("codigo", "")
 
         # Items directos en departamento
         items = dept.get("item", [])
         if not isinstance(items, list):
             items = [items] if items else []
         for item in items:
-            items_list.append(_item_to_dict(item, dept_nombre, dept_codigo, None))
+            items_list.append(_item_to_dict(item, dept_nombre, None))
 
         # Items en epígrafes directos
         epigrafes = dept.get("epigrafe", [])
@@ -1501,7 +1735,7 @@ def _extraer_items_seccion(seccion: dict) -> list[dict]:
             if not isinstance(items_ep, list):
                 items_ep = [items_ep] if items_ep else []
             for item in items_ep:
-                items_list.append(_item_to_dict(item, dept_nombre, dept_codigo, ep_nombre))
+                items_list.append(_item_to_dict(item, dept_nombre, ep_nombre))
 
         # Items en texto.epigrafe
         texto = dept.get("texto", {})
@@ -1515,13 +1749,13 @@ def _extraer_items_seccion(seccion: dict) -> list[dict]:
                 if not isinstance(items_t, list):
                     items_t = [items_t] if items_t else []
                 for item in items_t:
-                    items_list.append(_item_to_dict(item, dept_nombre, dept_codigo, ep_nombre))
+                    items_list.append(_item_to_dict(item, dept_nombre, ep_nombre))
 
     return items_list
 
 
 def _item_to_dict(
-    item: dict, dept_nombre: str, dept_codigo: str, epigrafe: str | None
+    item: dict, dept_nombre: str, epigrafe: str | None
 ) -> dict:
     """
     Convierte un item del sumario a diccionario estructurado.
@@ -1529,28 +1763,22 @@ def _item_to_dict(
     Args:
         item: Diccionario del item de la API
         dept_nombre: Nombre del departamento
-        dept_codigo: Código del departamento
         epigrafe: Nombre del epígrafe (opcional)
 
     Returns:
         Diccionario estructurado del documento
     """
-    url_pdf = item.get("url_pdf", {})
-    if isinstance(url_pdf, dict):
-        url_pdf = url_pdf.get("texto", "")
-
-    url_html = item.get("url_html", {})
-    if isinstance(url_html, dict):
-        url_html = url_html.get("texto", "")
+    # v1.6.0: Campos url_pdf, url_html y departamento_codigo eliminados
+    # Son derivables del identificador:
+    # - url_pdf: https://www.boe.es/boe/dias/YYYY/MM/DD/pdfs/{id}.pdf
+    # - url_html: https://www.boe.es/diario_boe/txt.php?id={id}
+    # - departamento_codigo: redundante con departamento (nombre legible)
 
     return {
         "identificador": item.get("identificador", ""),
         "titulo": item.get("titulo", ""),
         "departamento": dept_nombre,
-        "departamento_codigo": dept_codigo,
         "epigrafe": epigrafe,
-        "url_pdf": url_pdf,
-        "url_html": url_html,
     }
 
 
diff --git a/tests/test_casos_uso_smart_nav.py b/tests/test_casos_uso_smart_nav.py
index 22494d4..a472443 100644
--- a/tests/test_casos_uso_smart_nav.py
+++ b/tests/test_casos_uso_smart_nav.py
@@ -311,7 +311,7 @@ class TestIntermediateGetLawStructureSummary:
         # Buscar LIBRO PRIMERO
         libro_primero = None
         for item in result["estructura"]:
-            if "PRIMERO" in item["nombre"].upper():
+            if "PRIMERO" in item["titulo"].upper():
                 libro_primero = item
                 break
 
@@ -329,7 +329,7 @@ class TestIntermediateGetLawStructureSummary:
         # Buscar LIBRO SEGUNDO
         libro_segundo = None
         for item in result["estructura"]:
-            if "SEGUNDO" in item["nombre"].upper():
+            if "SEGUNDO" in item["titulo"].upper():
                 libro_segundo = item
                 break
 
@@ -441,7 +441,7 @@ class TestAdvancedAnalysis:
                 ratio = libro["num_modificados"] / libro["num_articulos"]
                 if ratio > max_ratio:
                     max_ratio = ratio
-                    libro_mas_modificado = libro["nombre"]
+                    libro_mas_modificado = libro["titulo"]
 
         assert libro_mas_modificado is not None
 
@@ -473,9 +473,9 @@ class TestAdvancedNavigation:
         # Navegar hasta TÍTULO IV del LIBRO PRIMERO
         capitulos_titulo_iv = 0
         for libro in result["estructura"]:
-            if "PRIMERO" in libro["nombre"].upper():
+            if "PRIMERO" in libro["titulo"].upper():
                 for titulo in libro["hijos"]:
-                    if "TÍTULO IV" in titulo["nombre"].upper():
+                    if "TÍTULO IV" in titulo["titulo"].upper():
                         capitulos_titulo_iv = len(titulo["hijos"])
                         break
                 break
diff --git a/tests/test_e2e_smart_summary.py b/tests/test_e2e_smart_summary.py
index 4d56949..c21c1a9 100644
--- a/tests/test_e2e_smart_summary.py
+++ b/tests/test_e2e_smart_summary.py
@@ -103,11 +103,11 @@ class TestGetBoeSummarySectionE2E:
         assert len(result["documentos"]) > 0
 
         # Verificar estructura de documentos
+        # v1.6.0: url_pdf y url_html eliminados (derivables del identificador)
         doc = result["documentos"][0]
         assert "identificador" in doc
         assert "titulo" in doc
         assert "departamento" in doc
-        assert "url_pdf" in doc
 
     @pytest.mark.asyncio
     async def test_section_paginacion(self):
